"""Remediation data models for AutoPurple."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, Literal, Optional

from dataclasses_json import DataClassJsonMixin, config

# Type aliases
MCPServer = Literal['ccapi', 'cfn']
RemediationStatus = Literal['planned', 'executed', 'rolled_back', 'failed']


@dataclass(slots=True)
class RemediationPlan(DataClassJsonMixin):
    """A remediation plan generated by Claude."""
    
    id: str
    finding_id: str
    planned_change: Dict[str, Any]  # Claude plan (human-readable + machine)
    mcp_server: MCPServer
    mcp_call: Dict[str, Any]  # exact payload sent to MCP
    executed_at: Optional[datetime] = field(default=None)
    status: RemediationStatus = field(default='planned')
    audit_ref: Optional[str] = field(default=None)  # ARN/stack-id/tx-id
    created_at: datetime = field(
        default_factory=datetime.utcnow,
        metadata=config(encoder=datetime.isoformat, decoder=datetime.fromisoformat)
    )
    updated_at: datetime = field(
        default_factory=datetime.utcnow,
        metadata=config(encoder=datetime.isoformat, decoder=datetime.fromisoformat)
    )
    
    def __post_init__(self) -> None:
        """Validate remediation plan data after initialization."""
        if not self.id:
            raise ValueError("Remediation ID cannot be empty")
        if not self.finding_id:
            raise ValueError("Finding ID cannot be empty")
        if not self.planned_change:
            raise ValueError("Planned change cannot be empty")
        if not self.mcp_call:
            raise ValueError("MCP call cannot be empty")
    
    def execute(self, audit_ref: str) -> None:
        """Mark the remediation as executed."""
        self.status = 'executed'
        self.executed_at = datetime.utcnow()
        self.audit_ref = audit_ref
        self.updated_at = datetime.utcnow()
    
    def rollback(self) -> None:
        """Mark the remediation as rolled back."""
        self.status = 'rolled_back'
        self.updated_at = datetime.utcnow()
    
    def fail(self, error_message: str) -> None:
        """Mark the remediation as failed."""
        self.status = 'failed'
        self.notes = error_message
        self.updated_at = datetime.utcnow()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert remediation plan to dictionary for database storage."""
        return {
            'id': self.id,
            'finding_id': self.finding_id,
            'planned_change': self.planned_change,
            'mcp_server': self.mcp_server,
            'mcp_call': self.mcp_call,
            'executed_at': self.executed_at.isoformat() if self.executed_at else None,
            'status': self.status,
            'audit_ref': self.audit_ref,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> RemediationPlan:
        """Create remediation plan from dictionary."""
        # Handle datetime fields
        if isinstance(data.get('executed_at'), str):
            data['executed_at'] = datetime.fromisoformat(data['executed_at'])
        if isinstance(data.get('created_at'), str):
            data['created_at'] = datetime.fromisoformat(data['created_at'])
        if isinstance(data.get('updated_at'), str):
            data['updated_at'] = datetime.fromisoformat(data['updated_at'])
        
        return cls(**data)
    
    @property
    def is_executed(self) -> bool:
        """Check if the remediation has been executed."""
        return self.status == 'executed'
    
    @property
    def is_failed(self) -> bool:
        """Check if the remediation failed."""
        return self.status == 'failed'
    
    @property
    def is_rolled_back(self) -> bool:
        """Check if the remediation was rolled back."""
        return self.status == 'rolled_back'
    
    @property
    def planned_change_summary(self) -> str:
        """Get a summary of the planned change."""
        if isinstance(self.planned_change, dict):
            keys = list(self.planned_change.keys())
            return f"Change keys: {', '.join(keys[:3])}{'...' if len(keys) > 3 else ''}"
        return str(self.planned_change)[:100] + "..." if len(str(self.planned_change)) > 100 else str(self.planned_change)

